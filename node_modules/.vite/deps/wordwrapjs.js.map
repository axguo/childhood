{
  "version": 3,
  "sources": ["../../wordwrapjs/index.js"],
  "sourcesContent": ["/**\n * @module wordwrapjs\n */\n\n/**\n * Wordwrap options.\n * @typedef {Object} WordwrapOptions\n * @property {number} [width=30] - The max column width in characters.\n * @property {boolean} [break=false] - If true, words exceeding the specified `width` will be forcefully broken\n * @property {boolean} [noTrim=false] - By default, each line output is trimmed. If `noTrim` is set, no line-trimming occurs - all whitespace from the input text is left in.\n * @property {string} [eol='\\n'] - The end of line character to use. Defaults to `\\n`.\n */\n\nconst re = {\n  chunk: /[^\\s-]+?-\\b|\\S+|\\s+|\\r\\n?|\\n/g,\n  ansiEscapeSequence: /\\u001b.*?m/g\n}\n\n/**\n * @alias module:wordwrapjs\n * @typicalname wordwrap\n */\nclass Wordwrap {\n  /**\n   * @param {string} text - The input text to wrap.\n   * @param {module:wordwrapjs~WordwrapOptions} [options]\n   */\n  constructor (text = '', options = {}) {\n    this._lines = String(text).split(/\\r\\n|\\n/g)\n    this.options = {\n      eol: '\\n',\n      width: 30,\n      ...options\n    }\n  }\n\n  lines () {\n    /* trim each line of the supplied text */\n    return this._lines.map(trimLine, this)\n\n      /* split each line into an array of chunks, else mark it empty */\n      .map(line => line.match(re.chunk) || ['~~empty~~'])\n\n      /* optionally, break each word on the line into pieces */\n      .map(lineWords => this.options.break\n        ? lineWords.map(breakWord, this)\n        : lineWords\n      )\n      .map(lineWords => lineWords.flat())\n\n      /* transforming the line of words to one or more new lines wrapped to size */\n      .map(lineWords => {\n        return lineWords\n          .reduce((lines, word) => {\n            const currentLine = lines[lines.length - 1]\n            if (replaceAnsi(word).length + replaceAnsi(currentLine).length > this.options.width) {\n              lines.push(word)\n            } else {\n              lines[lines.length - 1] += word\n            }\n            return lines\n          }, [''])\n      })\n      .flat()\n\n      /* trim the wrapped lines */\n      .map(trimLine, this)\n\n      /* filter out empty lines */\n      .filter(line => line.trim())\n\n      /* restore the user's original empty lines */\n      .map(line => line.replace('~~empty~~', ''))\n  }\n\n  wrap () {\n    return this.lines().join(this.options.eol)\n  }\n\n  toString () {\n    return this.wrap()\n  }\n\n  /**\n   * @param {string} text - the input text to wrap\n   * @param {module:wordwrapjs~WordwrapOptions} [options]\n   */\n  static wrap (text, options) {\n    const block = new this(text, options)\n    return block.wrap()\n  }\n\n  /**\n   * Wraps the input text, returning an array of strings (lines).\n   * @param {string} text - input text\n   * @param {module:wordwrapjs~WordwrapOptions} [options]\n   */\n  static lines (text, options) {\n    const block = new this(text, options)\n    return block.lines()\n  }\n\n  /**\n   * Returns true if the input text would be wrapped if passed into `.wrap()`.\n   * @param {string} text - input text\n   * @return {boolean}\n   */\n  static isWrappable (text = '') {\n    const matches = String(text).match(re.chunk)\n    return matches ? matches.length > 1 : false\n  }\n\n  /**\n   * Splits the input text into an array of words and whitespace.\n   * @param {string} text - input text\n   * @returns {string[]}\n   */\n  static getChunks (text) {\n    return text.match(re.chunk) || []\n  }\n}\n\nfunction trimLine (line) {\n  return this.options.noTrim ? line : line.trim()\n}\n\nfunction replaceAnsi (string) {\n  return string.replace(re.ansiEscapeSequence, '')\n}\n\n/**\n * break a word into several pieces\n * @param {string} word\n * @private\n */\nfunction breakWord (word) {\n  if (replaceAnsi(word).length > this.options.width) {\n    const letters = word.split('')\n    let piece\n    const pieces = []\n    while ((piece = letters.splice(0, this.options.width)).length) {\n      pieces.push(piece.join(''))\n    }\n    return pieces\n  } else {\n    return word\n  }\n}\n\nexport default Wordwrap\n"],
  "mappings": ";AAaA,IAAM,KAAK;AAAA,EACT,OAAO;AAAA,EACP,oBAAoB;AACtB;AAMA,IAAM,WAAN,MAAe;AAAA;AAAA;AAAA;AAAA;AAAA,EAKb,YAAa,OAAO,IAAI,UAAU,CAAC,GAAG;AACpC,SAAK,SAAS,OAAO,IAAI,EAAE,MAAM,UAAU;AAC3C,SAAK,UAAU;AAAA,MACb,KAAK;AAAA,MACL,OAAO;AAAA,MACP,GAAG;AAAA,IACL;AAAA,EACF;AAAA,EAEA,QAAS;AAEP,WAAO,KAAK,OAAO,IAAI,UAAU,IAAI,EAGlC,IAAI,UAAQ,KAAK,MAAM,GAAG,KAAK,KAAK,CAAC,WAAW,CAAC,EAGjD;AAAA,MAAI,eAAa,KAAK,QAAQ,QAC3B,UAAU,IAAI,WAAW,IAAI,IAC7B;AAAA,IACJ,EACC,IAAI,eAAa,UAAU,KAAK,CAAC,EAGjC,IAAI,eAAa;AAChB,aAAO,UACJ,OAAO,CAAC,OAAO,SAAS;AACvB,cAAM,cAAc,MAAM,MAAM,SAAS,CAAC;AAC1C,YAAI,YAAY,IAAI,EAAE,SAAS,YAAY,WAAW,EAAE,SAAS,KAAK,QAAQ,OAAO;AACnF,gBAAM,KAAK,IAAI;AAAA,QACjB,OAAO;AACL,gBAAM,MAAM,SAAS,CAAC,KAAK;AAAA,QAC7B;AACA,eAAO;AAAA,MACT,GAAG,CAAC,EAAE,CAAC;AAAA,IACX,CAAC,EACA,KAAK,EAGL,IAAI,UAAU,IAAI,EAGlB,OAAO,UAAQ,KAAK,KAAK,CAAC,EAG1B,IAAI,UAAQ,KAAK,QAAQ,aAAa,EAAE,CAAC;AAAA,EAC9C;AAAA,EAEA,OAAQ;AACN,WAAO,KAAK,MAAM,EAAE,KAAK,KAAK,QAAQ,GAAG;AAAA,EAC3C;AAAA,EAEA,WAAY;AACV,WAAO,KAAK,KAAK;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,KAAM,MAAM,SAAS;AAC1B,UAAM,QAAQ,IAAI,KAAK,MAAM,OAAO;AACpC,WAAO,MAAM,KAAK;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,MAAO,MAAM,SAAS;AAC3B,UAAM,QAAQ,IAAI,KAAK,MAAM,OAAO;AACpC,WAAO,MAAM,MAAM;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,YAAa,OAAO,IAAI;AAC7B,UAAM,UAAU,OAAO,IAAI,EAAE,MAAM,GAAG,KAAK;AAC3C,WAAO,UAAU,QAAQ,SAAS,IAAI;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,UAAW,MAAM;AACtB,WAAO,KAAK,MAAM,GAAG,KAAK,KAAK,CAAC;AAAA,EAClC;AACF;AAEA,SAAS,SAAU,MAAM;AACvB,SAAO,KAAK,QAAQ,SAAS,OAAO,KAAK,KAAK;AAChD;AAEA,SAAS,YAAa,QAAQ;AAC5B,SAAO,OAAO,QAAQ,GAAG,oBAAoB,EAAE;AACjD;AAOA,SAAS,UAAW,MAAM;AACxB,MAAI,YAAY,IAAI,EAAE,SAAS,KAAK,QAAQ,OAAO;AACjD,UAAM,UAAU,KAAK,MAAM,EAAE;AAC7B,QAAI;AACJ,UAAM,SAAS,CAAC;AAChB,YAAQ,QAAQ,QAAQ,OAAO,GAAG,KAAK,QAAQ,KAAK,GAAG,QAAQ;AAC7D,aAAO,KAAK,MAAM,KAAK,EAAE,CAAC;AAAA,IAC5B;AACA,WAAO;AAAA,EACT,OAAO;AACL,WAAO;AAAA,EACT;AACF;AAEA,IAAO,qBAAQ;",
  "names": []
}
