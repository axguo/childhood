// node_modules/wordwrapjs/index.js
var re = {
  chunk: /[^\s-]+?-\b|\S+|\s+|\r\n?|\n/g,
  ansiEscapeSequence: /\u001b.*?m/g
};
var Wordwrap = class {
  /**
   * @param {string} text - The input text to wrap.
   * @param {module:wordwrapjs~WordwrapOptions} [options]
   */
  constructor(text = "", options = {}) {
    this._lines = String(text).split(/\r\n|\n/g);
    this.options = {
      eol: "\n",
      width: 30,
      ...options
    };
  }
  lines() {
    return this._lines.map(trimLine, this).map((line) => line.match(re.chunk) || ["~~empty~~"]).map(
      (lineWords) => this.options.break ? lineWords.map(breakWord, this) : lineWords
    ).map((lineWords) => lineWords.flat()).map((lineWords) => {
      return lineWords.reduce((lines, word) => {
        const currentLine = lines[lines.length - 1];
        if (replaceAnsi(word).length + replaceAnsi(currentLine).length > this.options.width) {
          lines.push(word);
        } else {
          lines[lines.length - 1] += word;
        }
        return lines;
      }, [""]);
    }).flat().map(trimLine, this).filter((line) => line.trim()).map((line) => line.replace("~~empty~~", ""));
  }
  wrap() {
    return this.lines().join(this.options.eol);
  }
  toString() {
    return this.wrap();
  }
  /**
   * @param {string} text - the input text to wrap
   * @param {module:wordwrapjs~WordwrapOptions} [options]
   */
  static wrap(text, options) {
    const block = new this(text, options);
    return block.wrap();
  }
  /**
   * Wraps the input text, returning an array of strings (lines).
   * @param {string} text - input text
   * @param {module:wordwrapjs~WordwrapOptions} [options]
   */
  static lines(text, options) {
    const block = new this(text, options);
    return block.lines();
  }
  /**
   * Returns true if the input text would be wrapped if passed into `.wrap()`.
   * @param {string} text - input text
   * @return {boolean}
   */
  static isWrappable(text = "") {
    const matches = String(text).match(re.chunk);
    return matches ? matches.length > 1 : false;
  }
  /**
   * Splits the input text into an array of words and whitespace.
   * @param {string} text - input text
   * @returns {string[]}
   */
  static getChunks(text) {
    return text.match(re.chunk) || [];
  }
};
function trimLine(line) {
  return this.options.noTrim ? line : line.trim();
}
function replaceAnsi(string) {
  return string.replace(re.ansiEscapeSequence, "");
}
function breakWord(word) {
  if (replaceAnsi(word).length > this.options.width) {
    const letters = word.split("");
    let piece;
    const pieces = [];
    while ((piece = letters.splice(0, this.options.width)).length) {
      pieces.push(piece.join(""));
    }
    return pieces;
  } else {
    return word;
  }
}
var wordwrapjs_default = Wordwrap;
export {
  wordwrapjs_default as default
};
//# sourceMappingURL=wordwrapjs.js.map
